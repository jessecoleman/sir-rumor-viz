<!DOCTYPE html>
<meta charset="utf-8">
<style>

.slider {
    position: absolute;
    left: 0px;
    top: 0px;
}

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.top-buffer { 
    margin-top: 20px; 
}

ul {
    list-style-type: none;
}

li.spreader {
    padding: 4px;
    background-color: #E57373;
}

li.stifler {
    padding: 4px;
    background-color: #4FC3F7;
}

</style>

</style>
<div class="container top-buffer">
    <div class="row">
        <div id="graph" class="col-sm-12 col-md-8">
            <span class="slider">
            <label for="density">Density</label>
            <input id="density" type="range" min="0.01" max="0.02" step="0.0025">
            <label for="cluster">Clustering Coefficient</label>
            <input id="cluster" type="range" min="0.5" max="0.9" step="0.1">
            <!--<svg id="graph"></svg>-->
            </span>
        </div>
        <div id="rumor-list" class="col-sm-12 col-md-4">
        </div>
        <div id="hist" class="col-sm-4">
        </div>
    </div>
</div>


<link 
    rel="stylesheet" 
    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
    crossorigin="anonymous"> 
<script
  src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
  integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E="
  crossorigin="anonymous"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

// svg to display network
var svg = d3.select("#graph").append("svg");
//var width = $("#graph").parent().width();
var width = $("#graph").outerWidth();
svg.attr("width", width)
    .attr("height", "80vh");
var height = $("#graph").outerHeight();

$(document).ready(function() {
    redraw($("#density").val(), $("#cluster").val())
});

$("#cluster").on("change", function() {
    var clustering_coeff = $(this).val();
    var density = $("#density").val();
    redraw(density, clustering_coeff);
});

$("#density").on("change", function() {
    var density = $(this).val();
    var clustering_coeff = $("#cluster").val();
    redraw(density, clustering_coeff);
});

var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip");

var activeNode = -1;

function updateTooltip(rumors) {
   tooltip.html(function(d) {
        var text = "<ul>";
        Object.keys(rumors).forEach(function(rumor) {
            text += "<li class=\"" + rumors[rumor] + "\">" + rumor + " " + rumors[rumor] + "</li>";
        })
        return text; 
    })
    .style("left", (d3.event.pageX) + "px")
    .style("top", (d3.event.pageY) + "px");
}

function redraw(density, clustering_coeff) {

    var totalIndividuals = 0;

    d3.selectAll("line").remove();
    d3.selectAll("circle").remove();

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink(graph.links)
            .id(function(d) { return d.id; })
        )
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));

    d3.json(`data_${density}_${clustering_coeff}.json`, function(error, graph) {
        if (error) throw error;
    
        d3.select("#rumor-list").selectAll("svg").remove();

        graph.nodes.forEach((node) => {
            totalIndividuals++;
            node.rumors = {};
            node.neighbors = [];
            node.spreading = 0;
        });
    
        graph.links.forEach((l) => {
            graph.nodes[l.target].neighbors.push(l.source);
        });
    
        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke-width", function(d) { return 1; });
    
        var nodes = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", 5)
            .attr("fill", function(d) { return d3.interpolateReds(0); })
            .style("stroke", "#666")
            .on("mouseover", function(node) {
                activeNode = node.id;

                tooltip.transition()
                    .duration(200)
                    .style("opacity", 1);

                tooltip.html(function(d) {
                    var text = "<ul>";
                    Object.keys(node.rumors).forEach(function(rumor) {
                        text += "<li class=\"" + 
                            node.rumors[rumor] + 
                            "\">" + rumor + " " + 
                            node.rumors[rumor] + "</li>";
                    });
                    return text; 
                })
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY) + "px");
            })
            .on("mouseout", function(node) {
                activeNode = -1;
                tooltip.transition()
                    .duration(200)
                    .style("opacity", 0);

            })
            .on("click", infect)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            nodes
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
        }

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        var iter = 0;
        var rumor = 0;
        var selectedRumor = -1;

        var charts = {};
        var rumorStates = {};

        function infect(node) {
            if (rumor == 0) {
                startInterval();
            }
            d3.select(this).attr("fill", "#D32F2F");
            rumor++;

            rumorStates[rumor] = {};
            rumorStates[rumor].ignorant = totalIndividuals - 1;
            rumorStates[rumor].spreading = 1;
            rumorStates[rumor].stifling = 0;
            node.rumors[rumor] = "spreader";

            var chart = {};
            chart.rumor = rumor
            chart.margin = {top: 20, right: 20, bottom: 30, left: 30};
            chart.width = $("#rumor-list").outerWidth() - chart.margin.left - chart.margin.right;
            chart.height = 150 - chart.margin.top - chart.margin.bottom;
            chart.element = d3.select("#rumor-list")
                .insert("svg", ":first-child")
                .attr("id", rumor)
                .attr("width", chart.width + chart.margin.left + chart.margin.right)
                .attr("height", chart.height + chart.margin.top + chart.margin.bottom)
                .on("mouseover", function() { selectedRumor = chart.rumor; })
                .on("mouseout", function() { selectedRumor = -1; });

            chart.x = d3.scaleLinear()
                .rangeRound([0, chart.width])
                .domain([iter - 20, iter]);

            chart.y = d3.scaleLinear()
                .rangeRound([chart.height, 0])
                .domain([0, totalIndividuals]);

            chart.line = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.count); });

            chart.spreadLine = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.spreading); });

            chart.stifledLine = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.stifling); });

            chart.axisBottom = chart.element.append("g")
                .attr("transform", "translate(" + chart.margin.left + "," + (chart.margin.top + chart.height) + ")")
                .call(d3.axisBottom(chart.x).ticks(10));

            chart.axisLeft = chart.element.append("g")
                .attr("transform", "translate(" + (chart.margin.left + chart.width) + "," + chart.margin.top + ")")
                .call(d3.axisLeft(chart.y).ticks(5))
                .append("text")
                .attr("fill", "#000")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", "0.71em")
                .attr("text-anchor", "end")
                .text("Ratios");

            chart.line = d3.line()
                .x((d) => { return chart.margin.left + chart.x(d.iter); })
                .y((d) => { return chart.margin.top + chart.y(d.count); });

            chart.data = {
                "ignorant": [{"iter": iter, "count": totalIndividuals - 1}],
                "spreading": [{"iter": iter, "count": 1}],
                "stifling": [{"iter": iter, "count": 0}]
            };

            chart.lineIgnorant = chart.element.append("path")
                .data(chart.data.ignorant)
                .attr("class", "line ignorant")
                .attr("fill", "none")
                .attr("stroke", "#2196F3")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            chart.lineSpreading = chart.element.append("path")
                .data(chart.data.spreading)
                .attr("class", "line spreading")
                .attr("fill", "none")
                .attr("stroke", "#F44336")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            chart.lineStifling = chart.element.append("path")
                .data(chart.data.stifling)
                .attr("class", "line stifling")
                .attr("fill", "none")
                .attr("stroke", "#4CAF50")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            charts[rumor] = chart;
        }

        var lambda = 0.8;
        var gamma = 0.3;
        var eta = 0.2;
        var delta = 0.4;

        function startInterval() {
            d3.interval(function() {
                iter++;

                // interaction between nodes and neighbors
                graph.nodes.forEach(function(node) {

                    neighbor = graph.nodes[node.neighbors[Math.floor(Math.random()*node.neighbors.length)]];
                    // if neighbor has not yet interacted with other node this interval
                    if (!neighbor.hasOwnProperty("new_rumors")) {
                        neighbor.new_rumors = {};
                        Object.keys(node.rumors).forEach(function(rumor) {
                            if (node.rumors[rumor] == "spreader") {
                                if (!neighbor.rumors.hasOwnProperty(rumor)) {
                                    neighbor.new_rumors[rumor] = Math.random() < lambda ? "spreader" : "stifler";
                                } 
                            } else if (node.rumors[rumor] == "stifler") {
                                if (!neighbor.rumors.hasOwnProperty(rumor)) {
                                    neighbor.new_rumors[rumor] = Math.random() < gamma ? "spreader" : "stifler";
                                } else if (neighbor.rumors[rumor] == "spreader") {
                                    neighbor.new_rumors[rumor] = Math.random() < delta ? "spreader" : "stifler";
                                }
                                } else if (neighbor.rumors[rumor] == "spreader" && Math.random() < eta) {
                                neighbor.new_rumors[rumor] = "stifler";
                            }
                        });
                    }
                });

                Object.keys(rumorStates).forEach(function(r) {
                    rumorStates[r].ignorant = totalIndividuals;
                    rumorStates[r].spreading = 0;
                    rumorStates[r].stifling = 0;
                })
                // update graph data
                graph.nodes.forEach(function(node) {

                    if (node.hasOwnProperty("new_rumors")) {
                        Object.keys(node.new_rumors).forEach(function(rumor) {
                            node.rumors[rumor] = node.new_rumors[rumor];
                        });
                        delete node.new_rumors;
                    }

                   // count number of active rumors
                    node.spreading = 0;
                    node.stifling = 0;
                    Object.keys(node.rumors).forEach(function(r) {

                        if (node.rumors[r] == "spreader") {
                            rumorStates[r].spreading++;
                            rumorStates[r].ignorant--;
                            //node.spreading += 1 / Math.pow(rumor - r, 2);
                            node.spreading += 1;
                        } else if (node.rumors[r] == "stifler") {
                            rumorStates[r].stifling++;
                            rumorStates[r].ignorant--;
                            node.stifling += 1 / Math.pow(rumor - r, 2);
                        }
                    });

                    if (node.id == activeNode) {
                        tooltip.html(function(d) {
                            console.log(node.rumors);
                            var text = "<ul>";
                            Object.keys(node.rumors).forEach(function(rumor) {
                                text += "<li class=\"" + node.rumors[rumor] + "\">" + rumor + " " + node.rumors[rumor] + "</li>";
                            })
                            return text; 
                        })
                    }
                });

                nodes.style("fill", (node) => { 
                    if (selectedRumor == -1) {
                        // TODO
                        //return d3.interpolateRdYlGn((node.stifling - node.spreading) / 5);
                        return d3.interpolateReds(node.spreading / 5);
                    } else if (node.rumors[selectedRumor] == "spreader") {
                        return "#E57373";
                    } else if (node.rumors[selectedRumor] == "stifler") {
                        return "#81C784";
                    } else {
                        return d3.interpolateReds(0);
                    }
                });

                // update chart data
                Object.keys(charts).forEach(function(r) {

                    chart = charts[r];

                    chart.data.ignorant.push({"iter": iter, "count": rumorStates[r].ignorant});
                    chart.data.spreading.push({"iter": iter, "count": rumorStates[r].spreading});
                    chart.data.stifling.push({"iter": iter, "count": rumorStates[r].stifling});

                    chart.x.domain([iter - 20, iter]);
                    chart.axisBottom
                        .call(d3.axisBottom(chart.x).ticks(10))
                    chart.axisLeft
                        .call(d3.axisLeft(chart.y))
                        .append("text")
                        .attr("fill", "#000")
                        .attr("transform", "rotate(-90)")
                        .attr("y", 6)
                        .attr("dy", "0.71em")
                        .attr("text-anchor", "end")
                        .text("Ratios");

                    chart.lineIgnorant
                        .datum(chart.data.ignorant)
                        .attr("d", chart.line);
    
                    chart.lineSpreading
                        .datum(chart.data.spreading)
                        .attr("d", chart.line);

                    chart.lineStifling
                        .datum(chart.data.stifling)
                        .attr("d", chart.line);
                });
   
            }, 1000);
        }
    });
}

</script>