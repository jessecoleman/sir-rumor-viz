<!DOCTYPE html>
<meta charset="utf-8">
<style>

.slider {
    position: absolute;
    left: 0px;
    top: 0px;
}

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.top-buffer { 
    margin-top: 20px; 
}

ul {
    list-style-type: none;
}

li.spreader {
    padding: 4px;
    background-color: #E57373;
}

li.stifler {
    padding: 4px;
    background-color: #4FC3F7;
}

</style>

</style>
<div class="container top-buffer">
    <div class="row">
        <div id="flowchart" class="col-sm-12"></div>
    </div>
    <div class="row">
        <div id="graph" class="col-sm-12 col-md-8">
            <span class="slider">
                <label for="density">Density</label>
                <input id="density" type="range" min="0.01" max="0.02" step="0.0025">
                <label for="cluster">Clustering Coefficient</label>
                <input id="cluster" type="range" min="0.5" max="0.9" step="0.1">
            </span>
        </div>
        <div id="rumor-list" class="col-sm-12 col-md-4">
        </div>
        <div id="hist" class="col-sm-4">
        </div>
    </div>
</div>


<link 
    rel="stylesheet" 
    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
    crossorigin="anonymous"> 
<script
  src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
  integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E="
  crossorigin="anonymous"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

var flow = {}
flow.width = $("#flowchart").outerWidth();
flow.height = 100;
flow.svg = d3.select("#flowchart").append("svg")
    .attr("width", flow.width)
    .attr("height", flow.height);

flow.ignorant = flow.svg.append("g")
    .attr("transform", "translate(" + 
        (flow.width / 4) + "," + 
        (flow.height / 2) + ")");
 
flow.ignorant.append("rect")
    .attr("x", -40)
    .attr("y", -12.5)
    .attr("width", 80)
    .attr("height", 25)
    .style("stroke", "black")
    .style("fill", "none");

flow.ignorant.append("text")
    .attr("id", "ignorant")
    .attr("x", flow.ignorant.attr("height") / 2)
    .attr("y", flow.ignorant.attr("width") / 2)
    .attr("dy", "0.4em")
    .attr("text-anchor", "middle")
    .text("Ignorant");

flow.spreader = flow.svg.append("g")
    .attr("transform", "translate(" + 
        (flow.width / 2) + "," + 
        (flow.height / 2) + ")");
 
flow.spreader.append("rect")
    .attr("x", -40)
    .attr("y", -12.5)
    .attr("width", 80)
    .attr("height", 25)
    .style("stroke", "black")
    .style("fill", "none");

flow.spreader.append("text")
    .attr("id", "ignorant")
    .attr("x", flow.spreader.attr("height") / 2)
    .attr("y", flow.spreader.attr("width") / 2)
    .attr("dy", "0.4em")
    .attr("text-anchor", "middle")
    .text("Spreader");

flow.stifler = flow.svg.append("g")
    .attr("transform", "translate(" + 
        (3 * flow.width / 4) + "," + 
        (flow.height / 2) + ")");
 
flow.stifler.append("rect")
    .attr("x", -40)
    .attr("y", -12.5)
    .attr("width", 80)
    .attr("height", 25)
    .style("stroke", "black")
    .style("fill", "none");

flow.stifler.append("text")
    .attr("id", "ignorant")
    .attr("x", flow.ignorant.attr("height") / 2)
    .attr("y", flow.ignorant.attr("width") / 2)
    .attr("dy", "0.4em")
    .attr("text-anchor", "middle")
    .text("Stifler");

// TODO @Ethan or @Evan, create arrows between the three text boxes to resemble the chart
// on page 996 of this paper 
// https://www-sciencedirect-com.offcampus.lib.washington.edu/science/article/pii/S037843711200934X
flow.arrow = flow.svg
    .append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("refX", 6)
        .attr("refY", 6)
        .attr("markerWidth", 6)
        .attr("markerHeight", 4)
        .attr("orient", "auto")
    .append("path")
    .attr("d", "M 0 0 12 6 0 12 3 6")
    .style("fill", "black");

// svg to display network
var graphSvg = d3.select("#graph").append("svg");
//var width = $("#graph").parent().width();
var width = $("#graph").outerWidth();
graphSvg.attr("width", width)
    .attr("height", "80vh");
var height = $("#graph").outerHeight();

$(document).ready(function() {
    redraw($("#density").val(), $("#cluster").val())
});

$("#cluster").on("change", function() {
    var clustering_coeff = $(this).val();
    var density = $("#density").val();
    redraw(density, clustering_coeff);
});

$("#density").on("change", function() {
    var density = $(this).val();
    var clustering_coeff = $("#cluster").val();
    redraw(density, clustering_coeff);
});

var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip");

function redraw(density, clustering_coeff) {

    var totalIndividuals = 0; // for chart viz
    var activeNode = -1; // for hover effect

    d3.selectAll("line").remove();
    d3.selectAll("circle").remove();

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink(graph.links)
            .id(function(d) { return d.id; })
        )
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));

    d3.json(`data_${density}_${clustering_coeff}.json`, function(error, graph) {
        if (error) throw error;
    
        d3.select("#rumor-list").selectAll("svg").remove();

        graph.nodes.forEach((node) => {
            totalIndividuals++;
            node.rumors = {};
            node.newRumors = {};
            node.neighbors = [];
            node.spreading = 0;
            node.rank = +node.rank;
        });
    
        graph.links.forEach((l) => {
            graph.nodes[l.target].neighbors.push(l.source);
        });
    
        var link = graphSvg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke-width", function(d) { return 1; });

        var radius = d3.scaleSqrt()
            .range([4, 7])
            .domain(d3.extent(graph.nodes, function(node) { return node.rank; }));
    
        var nodes = graphSvg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", (d) => { return radius(d.rank); })
            .attr("fill", function(d) { return d3.interpolateReds(0); })
            .style("stroke", "#666")
            .on("mouseover", function(node) {
                activeNode = node.id;

                tooltip.transition()
                    .duration(200)
                    .style("opacity", 1);

                tooltip.html(function(d) {
                    var text = "<ul>";
                    Object.keys(node.rumors).reverse().forEach(function(rumor) {
                        text += "<li class=\"" + 
                            node.rumors[rumor] + 
                            "\">" + rumor + " " + 
                            node.rumors[rumor] + "</li>";
                    });
                    return text; 
                })
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY) + "px");
            })
            .on("mouseout", function(node) {
                activeNode = -1;
                tooltip.transition()
                    .duration(200)
                    .style("opacity", 0);

            })
            .on("click", infect);
//            .call(d3.drag()
//                .on("start", dragstarted)
//                .on("drag", dragged)
//                .on("end", dragended));

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            nodes
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });
        }

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        var iter = 0;
        var rumor = 0;
        var selectedRumor = -1;

        var charts = {};
        var rumorStates = {};

        function infect(node) {
            if (rumor == 0) {
                startInterval();
            }
            d3.select(this).attr("fill", "#D32F2F");
            rumor++;

            rumorStates[rumor] = {};
            rumorStates[rumor].ignorant = totalIndividuals - 1;
            rumorStates[rumor].spreading = 1;
            rumorStates[rumor].stifling = 0;
            node.rumors[rumor] = "spreader";

            var chart = {};
            chart.rumor = rumor
            chart.margin = {top: 20, right: 20, bottom: 30, left: 30};
            chart.width = $("#rumor-list").outerWidth() - chart.margin.left - chart.margin.right;
            chart.height = 150 - chart.margin.top - chart.margin.bottom;
            chart.element = d3.select("#rumor-list")
                .insert("svg", ":first-child")
                .attr("id", rumor)
                .attr("width", chart.width + chart.margin.left + chart.margin.right)
                .attr("height", chart.height + chart.margin.top + chart.margin.bottom)
                .on("mouseover", function() { selectedRumor = chart.rumor; setNodeFill(nodes); })
                .on("mouseout", function() { selectedRumor = -1; setNodeFill(nodes); });

            chart.x = d3.scaleLinear()
                .rangeRound([0, chart.width])
                .domain([iter - 20, iter]);

            chart.y = d3.scaleLinear()
                .rangeRound([chart.height, 0])
                .domain([0, totalIndividuals]);

            chart.line = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.count); });

            chart.spreadLine = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.spreading); });

            chart.stifledLine = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.stifling); });

            chart.axisBottom = chart.element.append("g")
                .attr("transform", "translate(" + chart.margin.left + "," + (chart.margin.top + chart.height) + ")")
                .call(d3.axisBottom(chart.x).ticks(10));

            chart.axisLeft = chart.element.append("g")
                .attr("transform", "translate(" + (chart.margin.left + chart.width) + "," + chart.margin.top + ")")
                .call(d3.axisLeft(chart.y).ticks(5))
                .append("text")
                .attr("fill", "#000")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", "0.71em")
                .attr("text-anchor", "end")
                .text("Ratios");

            chart.line = d3.line()
                .x((d) => { return chart.margin.left + chart.x(d.iter); })
                .y((d) => { return chart.margin.top + chart.y(d.count); });

            chart.data = {
                "ignorant": [{"iter": iter, "count": totalIndividuals - 1}],
                "spreading": [{"iter": iter, "count": 1}],
                "stifling": [{"iter": iter, "count": 0}]
            };

            chart.lineIgnorant = chart.element.append("path")
                .data(chart.data.ignorant)
                .attr("class", "line ignorant")
                .attr("fill", "none")
                .attr("stroke", "#2196F3")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            chart.lineSpreading = chart.element.append("path")
                .data(chart.data.spreading)
                .attr("class", "line spreading")
                .attr("fill", "none")
                .attr("stroke", "#F44336")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            chart.lineStifling = chart.element.append("path")
                .data(chart.data.stifling)
                .attr("class", "line stifling")
                .attr("fill", "none")
                .attr("stroke", "#4CAF50")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line);

            charts[rumor] = chart;
        }

        var lambda = 0.8;
        var gamma = 0.3;
        var eta = 0.6;
        var delta = 0.2;

        function startInterval() {
            d3.interval(function() {
                iter++;

                // interaction between nodes and neighbors
                graph.nodes.forEach(function(node) {

                    neighbor = graph.nodes[node.neighbors[Math.floor(Math.random()*node.neighbors.length)]];

                    // probability of interacting decreases with number of previous interactions
                    if (1 / (Object.keys(neighbor.rumors).length + 1) > Math.random()) {

                        var spread = false;
                        var rumorAge = 1;
                        var r = Math.random();                        
                        Object.keys(node.rumors).sort().reverse().forEach(function(rumor) {
                            // probability of sharing rumor given age
                            if (1 / (1 - Math.pow(2, rumorAge)) < r && !spread) {
                                spread = true;
                                if (node.rumors[rumor] == "spreader") {
                                    if (!neighbor.rumors.hasOwnProperty(rumor)) {
                                        neighbor.newRumors[rumor] = Math.random() < lambda ? "spreader" : "stifler";
                                    } else if (neighbor.rumors[rumor] == "spreader") {
                                        neighbor.newRumors[rumor] = Math.random() > gamma ? "spreader" : "stifler";
                                    } 
                                } else if (node.rumors[rumor] == "stifler" && neighbor.rumors[rumor] == "spreader") {
                                    neighbor.newRumors[rumor] = Math.random() > eta ? "spreader" : "stifler";
                                }
                            } else if (Math.random() < delta) {
                                // probability that node forgets rumor
                                node.newRumors[rumor] = "stifler";
                            }
                            rumorAge++;
                        });
                    }
                });

                Object.keys(rumorStates).forEach(function(r) {
                    rumorStates[r].ignorant = totalIndividuals;
                    rumorStates[r].spreading = 0;
                    rumorStates[r].stifling = 0;
                })
                // update graph data
                graph.nodes.forEach(function(node) {

                    Object.keys(node.newRumors).forEach(function(rumor) {
                        node.rumors[rumor] = node.newRumors[rumor];
                    });
                    node.newRumors = {};

                   // count number of active rumors
                    node.spreading = 0;
                    node.stifling = 0;
                    Object.keys(node.rumors).forEach(function(r) {

                        if (node.rumors[r] == "spreader") {
                            rumorStates[r].spreading++;
                            rumorStates[r].ignorant--;
                            //node.spreading += 1 / Math.pow(rumor - r, 2);
                            node.spreading += 1;
                        } else if (node.rumors[r] == "stifler") {
                            rumorStates[r].stifling++;
                            rumorStates[r].ignorant--;
                            node.stifling += 1 / Math.pow(rumor - r, 2);
                        }
                    });

                    if (node.id == activeNode) {
                        tooltip.html(function(d) {
                            var text = "<ul>";
                            Object.keys(node.rumors).reverse().forEach(function(rumor) {
                                text += "<li class=\"" + node.rumors[rumor] + "\">" + 
                                    rumor + " " + node.rumors[rumor] + "</li>";
                            })
                            return text; 
                        })
                    }
                });

                setNodeFill(nodes);

                // update chart data
                Object.keys(charts).forEach(function(r) {

                    chart = charts[r];

                    chart.data.ignorant.push({"iter": iter, "count": rumorStates[r].ignorant});
                    chart.data.spreading.push({"iter": iter, "count": rumorStates[r].spreading});
                    chart.data.stifling.push({"iter": iter, "count": rumorStates[r].stifling});

                    chart.x.domain([iter - 20, iter]);
                    chart.axisBottom
                        .call(d3.axisBottom(chart.x).ticks(10))
                    chart.axisLeft
                        .call(d3.axisLeft(chart.y))
                        .append("text")
                        .attr("fill", "#000")
                        .attr("transform", "rotate(-90)")
                        .attr("y", 6)
                        .attr("dy", "0.71em")
                        .attr("text-anchor", "end")
                        .text("Ratios");

                    chart.lineIgnorant
                        .datum(chart.data.ignorant)
                        .attr("d", chart.line);
    
                    chart.lineSpreading
                        .datum(chart.data.spreading)
                        .attr("d", chart.line);

                    chart.lineStifling
                        .datum(chart.data.stifling)
                        .attr("d", chart.line);
                });
   
            }, 1000);
        }

        function setNodeFill(nodes) {
            nodes.style("fill", (node) => { 
                if (selectedRumor == -1) {
                    return d3.interpolateReds(Math.pow(1 - (1 / Math.pow(2, node.spreading)), 2));
                } else if (node.rumors[selectedRumor] == "spreader") {
                    return "#E57373";
                } else if (node.rumors[selectedRumor] == "stifler") {
                    return "#81C784";
                } else {
                    return d3.interpolateReds(0);
                }
            });
        }
    });
}



</script>