<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

.top-buffer { 
    margin-top: 20px; 
}

</style>

</style>
<div class="container top-buffer">
    <div class="row">
        <div id="graph" class="col-sm-12 col-md-8">
            <span>
            <label for="density">Density</label>
            <input id="density" type="range" min="0.01" max="0.02" step="0.0025">
            <label for="cluster">Clustering Coefficient</label>
            <input id="cluster" type="range" min="0.5" max="0.9" step="0.1">
            <!--<svg id="graph"></svg>-->
            </span>
        </div>
        <div id="rumor-list" class="col-sm-12 col-md-4">
        </div>
        <div id="hist" class="col-sm-4">
        </div>
    </div>
</div>


<link 
    rel="stylesheet" 
    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" 
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" 
    crossorigin="anonymous"> 
<script
  src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
  integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E="
  crossorigin="anonymous"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

// svg to display network
var svg = d3.select("#graph").append("svg");
//var width = $("#graph").parent().width();
var width = $("#graph").outerWidth();
svg.attr("width", width)
    .attr("height", "80vh");
var height = $("#graph").outerHeight();

$(document).ready(function() {
    redraw($("#density").val(), $("#cluster").val())
})

$("#cluster").on("change", function() {
    var clustering_coeff = $(this).val();
    var density = $("#density").val();
    redraw(density, clustering_coeff);
})

$("#density").on("change", function() {
    var density = $(this).val();
    var clustering_coeff = $("#cluster").val();
    redraw(density, clustering_coeff);
})


//var lines = d3.select("#lines"),
//    margin = {top: 20, right: 20, bottom: 30, left: 50},
//    line_width = +lines.attr("width") - margin.left - margin.right,
//    line_height = +lines.attr("height") - margin.top - margin.bottom,
//    g = lines.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//var x = d3.scaleLinear()
//    .rangeRound([0, line_width])
//    .domain([-4, 0]);//
//var y = d3.scaleLinear()
//    .rangeRound([line_height, 0])
//    .domain([0, 1]);

//var line = d3.line()
//    .x((d) => { return x(d.iter); })
//    .y((d) => { return y(d.pct); })

//g.append("g")
//    .attr("transform", "translate(0, " + height + ")")
//    .call(d3.axisBottom(x))
//    .attr("class", "y axis");
//
//g.append("g")
//    .call(d3.axisLeft(y))
//    .attr("class", "x axis")
//    .append("text")
//    .attr("fill", "#000")
//    .attr("transform", "rotate(-90)")
//    .attr("y", 6)
//    .attr("dy", "0.71em")
//    .attr("text-anchor", "end")
//    .text("Percent");

//g.append("path")
//    .datum(distribution.susceptible)
//    .attr("class", "line")
//    .attr("fill", "none")
//    .attr("stroke", "steelblue")
//    .attr("stroke-linejoin", "round")
//    .attr("stroke-linecap", "round")
//    .attr("stroke-width", 1.5)
//    .attr("d", line);

var prob_inf = 0.04;
var prob_rec = 0.02;
var total_individuals = 0;

function redraw(density, clustering_coeff) {
    console.log(density, clustering_coeff);

    d3.selectAll("line").remove();
    d3.selectAll("circle").remove();

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink(graph.links)
            .id(function(d) { return d.id; })
        )
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));

    d3.json(`data_${density}_${clustering_coeff}.json`, function(error, graph) {
        if (error) throw error;
    
        graph.nodes.forEach((node) => {
            total_individuals++;
            node.rumors = {};
            node.neighbors = [];
            node.spreading = 0;
        });
    
        graph.links.forEach((l) => {
            graph.nodes[l.target].neighbors.push(l.source);
        });
    
        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke-width", function(d) { return 1; });
    
        var nodes = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", 5)
            .attr("fill", function(d) { return d3.interpolateReds(0); })
            .style("stroke", "#666")
            .on("click", infect)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
    
        var titles = nodes.append("title");

        d3.select("#rumor-list").selectAll("svg").remove();
    
        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);
    
        simulation.force("link")
            .links(graph.links);
    
        function ticked() {
          link
              .attr("x1", function(d) { return d.source.x; })
              .attr("y1", function(d) { return d.source.y; })
              .attr("x2", function(d) { return d.target.x; })
              .attr("y2", function(d) { return d.target.y; });
    
          nodes
              .attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; });
        }

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
    
        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }
    
        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        var iter = 0;
        var rumor = 1;
        var selectedRumor = -1;

        var charts = {};
        var spread = {};
        var maxSpread = 20;

        function infect(node) {
            spread[rumor] = 1;
            node.rumors[rumor] = "spreader";

            var chart = {};
            chart.rumor = rumor
            chart.margin = {top: 20, right: 20, bottom: 30, left: 30};
            chart.width = $("#rumor-list").outerWidth() - chart.margin.left - chart.margin.right;
            chart.height = 150 - chart.margin.top - chart.margin.bottom;
            chart.element = d3.select("#rumor-list")
                .insert("svg", ":first-child")
                .attr("id", rumor)
                .attr("width", chart.width + chart.margin.left + chart.margin.right)
                .attr("height", chart.height + chart.margin.top + chart.margin.bottom)
                .on("mouseover", function() { selectedRumor = chart.rumor; })
                .on("mouseout", function() { selectedRumor = -1; });

            chart.x = d3.scaleLinear()
                .rangeRound([0, chart.width])
                .domain([iter - 5, iter]);

            chart.y = d3.scaleLinear()
                .rangeRound([chart.height, 0])
                .domain([0, maxSpread]);

            chart.line = d3.line()
                .x((d) => { return chart.x(d.iter); })
                .y((d) => { return chart.y(d.count); });

            chart.axisBottom = chart.element.append("g")
                .attr("transform", "translate(0, " + chart.height + ")")
                .call(d3.axisBottom(chart.x).ticks(5));
            
            chart.axisLeft = chart.element.append("g")
                .attr("transform", "translate(" + chart.width + ",0)")
                .call(d3.axisLeft(chart.y).ticks(5))
                .append("text")
                .attr("fill", "#000")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", "0.71em")
                .attr("text-anchor", "end")
                .text("Ratios");

            chart.data = [{"iter": iter, "count": 1}];

            chart.element.append("path")
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", 1.5)
                .attr("d", chart.line(chart.data));
            
            charts[rumor] = chart;
            rumor++;
        }

        var lambda = 0.8;
        var gamma = 0.3;
        var eta = 0.2;
        var delta = 0.4;
    

        d3.interval(function() {
            iter++;
    
            graph.nodes.forEach(function(node) {

                neighbor = graph.nodes[node.neighbors[Math.floor(Math.random()*node.neighbors.length)]];
                // if neighbor has not yet interacted with other node this interval
                if (!neighbor.hasOwnProperty("new_rumors")) {
                    neighbor.new_rumors = {};
                    Object.keys(node.rumors).forEach(function(rumor) {
                        if (node.rumors[rumor] == "spreader") {
                            if (!neighbor.rumors.hasOwnProperty(rumor)) {
                                neighbor.new_rumors[rumor] = Math.random() < lambda ? "spreader" : "stifler";
                            } 
                        } else if (node.rumors[rumor] == "stifler") {
                            if (!neighbor.rumors.hasOwnProperty(rumor)) {
                                neighbor.new_rumors[rumor] = Math.random() < gamma ? "spreader" : "stifler";
                            } else if (neighbor.rumors[rumor] == "spreader") {
                                neighbor.new_rumors[rumor] = Math.random() < delta ? "spreader" : "stifler";
                            }
                         } else if (neighbor.rumors[rumor] == "spreader" && Math.random() < eta) {
                            neighbor.new_rumors[rumor] = "stifler";
                        }
                    });
                }
            });

            Object.keys(spread).forEach(function(rumor) { 
                spread[rumor] = 0;
            });
            // update graph data
            graph.nodes.forEach(function(node) {
                if (node.hasOwnProperty("new_rumors")) {
                    Object.keys(node.new_rumors).forEach(function(rumor) {
                        node.rumors[rumor] = node.new_rumors[rumor];
                    });
                    delete node.new_rumors;
                }

                // count number of active rumors
                node.spreading = 0;
                Object.keys(node.rumors).forEach(function(rumor) {
                    if (node.rumors[rumor] == "spreader") {
                        spread[rumor]++;
                        node.spreading++;
                    }
                });
            });
    
            nodes.style("fill", (node) => { 
                    if (selectedRumor == -1) {
                        return d3.interpolateReds(node.spreading / 5); 
                    } else if (node.rumors[selectedRumor] == "spreader") {
                        return "#E57373";
                    } else if (node.rumors[selectedRumor] == "stifler") {
                        return "#81C784";
                    } else {
                        return "#4FC3F7";
                    }
                })

    
            titles.text(function(node) { 
                var result = "";
                Object.keys(node.rumors).forEach(function(rumor) {
                    result += rumor + " " + node.rumors[rumor] + "\n";
                })
                return result; 
            });

            Object.keys(charts).forEach(function(rumor) {
                chart = charts[rumor];
                chart.data.push({"iter": iter, "count": spread[rumor]});
                chart.x.domain([iter - 5, iter]);
                chart.y.domain([0, maxSpread]);
                console.log(maxSpread);
                
                if (spread[rumor] > maxSpread) {
                    console.log(maxSpread);
                    maxSpread = spread[rumor];
                }

                //chart.element.transition();
                chart.axisBottom
                    .call(d3.axisBottom(chart.x).ticks(5))
                chart.axisLeft
                    .call(d3.axisLeft(chart.y))
                    .append("text")
                    .attr("fill", "#000")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", "0.71em")
                    .attr("text-anchor", "end")
                    .text("Ratios");

                chart.element.select(".line")
                    .datum(chart.data)
                    .attr("d", chart.line);
            })
    
    //      var current = {"susceptible": 0, "infected": 0, "recovered": 0};
    
    //      d3.selectAll("circle")
    //          .attr("fill", (d) => {
    //              current[d.status]++;
    //              if (d.status == "infected") return "red";
    //              else if (d.status == "recovered") return "blue";
    //              else return "green";
    //          })
    
    //      Object.keys(current).forEach(function(status) {
    //          console.log(status)
    //          console.log(distribution[status])
    //        distribution[status].shift()
    //        distribution[status].push({"iter": iter, "pct": current[status] / total_individuals})
    //      })
    //
    //      var lines = d3.select("#lines").transition();
    //
    //      x.domain([iter - 5, iter]);
    //      lines.select(".x.axis")
    //          .duration(250)
    //          .call(d3.axisBottom(x));
    //
    //      y.domain([0, 1]);
    //      lines.select(".y.axis")
    //          .duration(250)
    //          .call(d3.axisLeft(y));
    //
    //      lines.select(".line")
    //          .duration(250)
    //          .attr("d", line(duration.susceptible));
    
        }, 1000);
        
    });
}

</script>